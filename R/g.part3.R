g.part3 = function(metadatadir=c(),f0,f1,anglethreshold = 5,timethreshold = 5, 
                   acc.metric="ENMO", ignorenonwear=TRUE, overwrite=FALSE, desiredtz="",
                   constrain2range=TRUE,do.part3.pdf=TRUE, do.parallel = TRUE,
                   myfun=c(), maxNcores=c()) {
  # description: function to apply sleep detection functions to milestone data generated by g.part1
  #------------------------------------
  # create output directory if it does not exist
  if (file.exists(paste(metadatadir,sep=""))) {
  } else {
    dir.create(file.path(metadatadir))
  }
  if (file.exists(paste(metadatadir,"/meta/ms3.out",sep=""))) {
  } else {
    dir.create(file.path(paste(metadatadir,"/meta",sep=""),"ms3.out"))
    dir.create(file.path(paste(metadatadir,"/meta",sep=""),"sleep.qc"))
  }
  #------------------------------------------------------
  fnames  =dir(paste(metadatadir,"/meta/ms2.out",sep=""))
  if (f1 > length(fnames) | f1 == 0) f1 = length(fnames)
  if (f0 > length(fnames) | f0 == 0) f0 = 1
  #========================================================================
  # check which files have already been processed, such that no double work is done
  # ffdone a matrix with all the binary filenames that have been processed
  ffdone = fdone = dir(paste(metadatadir,"/meta/ms3.out",sep=""))
  if (length(fdone) > 0) {
    for (ij in 1:length(fdone)) {
      tmp = unlist(strsplit(fdone[ij],".RData"))
      ffdone[ij] = tmp[1]
    }
  } else {
    ffdone = c()
  }
  nightsperpage =7
  
  
  if (do.parallel == TRUE) {
    cores=parallel::detectCores()
    Ncores = cores[1]
    if (Ncores > 3) {
      if (length(maxNcores) == 0) maxNcores = Ncores
      Ncores2use = min(c(Ncores-1, maxNcores))
      cl <- parallel::makeCluster(Ncores2use) #not to overload your computer
      doParallel::registerDoParallel(cl)
    } else {
      cat(paste0("\nparallel processing not possible because number of available cores (",Ncores,") < 4"))
      do.parallel = FALSE
    }
  }
  t1 = Sys.time() # copied here
  if (do.parallel == TRUE) {
    cat(paste0('\n Busy processing ... see ', metadatadir,'/meta/ms3.out', ' for progress\n'))
  }
  # check whether we are indevelopment mode:
  GGIRinstalled = is.element('GGIR', installed.packages()[,1])
  packages2passon = functions2passon = NULL
  GGIRloaded = "GGIR" %in% .packages()
  if (GGIRloaded) { #pass on package
    packages2passon = 'GGIR'
    errhand = 'pass'
  } else { # pass on functions
    functions2passon = c("g.sib.det", "g.detecmidnight", "iso8601chartime2POSIX", "g.sib.plot", "g.sib.sum")
    errhand = 'stop'
  }
  fe_dopar = foreach::`%dopar%`
  fe_do = foreach::`%do%`
  i = 0 # declare i because foreach uses it, without declaring it
  `%myinfix%` = ifelse(do.parallel, fe_dopar, fe_do) # thanks to https://stackoverflow.com/questions/43733271/how-to-switch-programmatically-between-do-and-dopar-in-foreach
  output_list =foreach::foreach(i=f0:f1, .packages = packages2passon,
                                .export=functions2passon, .errorhandling=errhand) %myinfix% {
    tryCatchResult = tryCatch({
      # for (i in f0:f1) {
      FI = file.info(paste(metadatadir,"/meta/ms2.out/",fnames[i],sep=""))
      if (is.na(FI$size) == TRUE) FI$size = 0
      if (FI$size == 0 | is.na(FI$size) == TRUE | length(FI$size) == 0) {
        cat(paste("P3 file ",fnames[i],sep=""))
        cat("Filename not recognised")
      }
      fname = unlist(strsplit(fnames[i],".RData"))[1]
      # fname = unlist(strsplit(fname,"eta_"))[2]
      #=========================================================
      #check whether file has already been processed
      #by comparing filename to read with list of processed files
      if (length(ffdone) > 0) {
        if (length(which(ffdone == fname)) > 0) { 
          skip = 1 #skip this file because it was analysed before")
        } else {
          skip = 0 #do not skip this file
        }
      } else {
        skip = 0
      }
      if (overwrite == TRUE) skip = 0
      if (skip == 0) {  
        # Load previously stored meta-data from part1.R
        cat(paste(" ",i,sep=""))
        IMP = M = c()
        load(paste(metadatadir,"/meta/basic/meta_",fnames[i],sep=""))
        load(paste(metadatadir,"/meta/ms2.out/",fnames[i],sep=""))
        if (M$filecorrupt == FALSE & M$filetooshort == FALSE) {
          SLE = g.sib.det(M,IMP,I,twd=c(-12,12),timethreshold=timethreshold,anglethreshold=anglethreshold,
                          acc.metric=acc.metric,desiredtz=desiredtz,constrain2range=constrain2range, 
                          myfun=myfun)
          L5list = SLE$L5list
          sptwindow_HDCZA_end = SLE$sptwindow_HDCZA_end
          sptwindow_HDCZA_start = SLE$sptwindow_HDCZA_start
          tib.threshold = SLE$tib.threshold
          if (length(SLE$output) > 0 & SLE$detection.failed == FALSE) {
            id = as.character(unlist(strsplit(I$filename,"_"))[1])
            datename = as.character(unlist(strsplit(as.character(as.matrix(M$metashort[1]))," "))[1])
            plottitle = " " #datename#"blablbalbal"# paste("File: ",i," | date: ",datename," | filename: ",fna2," | night: ",j,sep="")
            if (do.part3.pdf == TRUE) {
              pdf(paste(metadatadir,"/meta/sleep.qc/graphperday_id_",id,"_",I$filename,".pdf",sep=""),width=8.2,height=11.7)
              g.sib.plot(SLE,M,I,plottitle,nightsperpage=nightsperpage,desiredtz=desiredtz)
              dev.off()
            }
            sib.cla.sum = c()
            sib.cla.sum = g.sib.sum(SLE,M,ignorenonwear=ignorenonwear,desiredtz=desiredtz)
            save(sib.cla.sum,L5list,sptwindow_HDCZA_end, sptwindow_HDCZA_start, tib.threshold, 
                 file=paste(metadatadir,"/meta/ms3.out/",fname,".RData",sep=""))
          }
        }
      }
      # } # for loop
  }) # END tryCatch
  return(tryCatchResult)
  }
  if (do.parallel == TRUE) {
    on.exit(parallel::stopCluster(cl))
  }
  for (oli in 1:length(output_list)) { # logged error and warning messages
    if (is.null(unlist(output_list[oli])) == FALSE) {
      cat(paste0("\nErrors and warnings for ",fnames[oli]))
      print(unlist(output_list[oli])) # print any error and warnings observed
    }
  }
}
