g.report.part5 = function(metadatadir=c(),f0=c(),f1=c(),loglocation=c(),
                          includenightcrit=c(),includedaycrit=c()) {
  # description: function to load milestone data generated by g.part5 and to merge these into a spreadsheet
  # here no additional information of analyses are added. This function therefore is primary to wrap up the up the output
  # from parallel processed accelerometer files
  
  
  getValidDayIndices = function(x, includenightcrit, includedaycrit) {
    maxpernwnight = (1 - (includenightcrit / 24)) * 100
    maxpernwday = (1 - (includedaycrit / 24)) * 100
    # Temporarily replace 4 March 2020...
    indices = which(x$nonwear_perc_wakinghours <= maxpernwday &
                      (x$guider == "sleeplog" | (x$guider != "sleeplog" & x$nonwear_perc_sleepperiod < 66)) &
                      x$nonwear_perc_sleepperiod <= maxpernwnight & 
                      x$dur_sleepperiod_min > 0 & x$dur_wakinghours_min > 0)
    # by ...
    # indices = which(x$dur_sleepperiodsleep_min > 0 & x$dur_wakinghours_min > 0)
    return(indices)
  }
  
  ms5.out = "/meta/ms5.out"
  if (file.exists(paste(metadatadir,ms5.out,sep=""))) {
    if (length(dir(paste(metadatadir,ms5.out,sep=""))) == 0) {
      try.generate.report = FALSE #do not run this function if there is no milestone data from g.part5
    } else {
      try.generate.report = TRUE
    }
  } else {
    try.generate.report = FALSE #do not run this function if there is no milestone data from g.part5
    warning('Cannot generate part5 report because no part 5 milestone data is available. First run part 5 with argument mode=5.')
  }
  if (try.generate.report == TRUE) {
    #======================================================================
    # loop through meta-files
    fnames.ms5 = list.files(paste0(metadatadir,ms5.out),full.names=TRUE)
    if(f1 > length(fnames.ms5)) f1 = length(fnames.ms5)
    cat(" loading all the milestone data from part 5 this can take a few minutes\n")
    myfun = function(x) { 
      load(file=x)
      cut = which(output[,1] == "")
      if (length(cut) > 0 & length(cut) < nrow(output)) {
        output = output[-cut,which(colnames(output) != "")]
      }
      
      out = as.matrix(output)
    }
    outputfinal = as.data.frame(do.call(rbind,lapply(fnames.ms5[f0:f1],myfun)),stringsAsFactors=FALSE)
    # cut = which(outputfinal[1,] == "" & outputfinal[2,] == "")
    cut = which(sapply(outputfinal, function(x)all(x=="")) == TRUE)# Find columns filled with missing values which(output[1,] == "" & output[2,] == "")
    if (length(cut) > 0) {
      outputfinal = outputfinal[,-cut]
    }
    # cut = which(outputfinal[1,] == "")
    # cut2 = which(outputfinal[,1] == "" & outputfinal[,2] == "")
    cut2 = which(sapply(outputfinal, function(x)all(x=="")) == TRUE)# Find columns filled with missing values which(output[1,] == "" & output[2,] == "")
    if (length(cut2) > 0) {
      outputfinal = outputfinal[-cut2,]
    }
    #-------------------------------------------
    # clean spreadsheet: => commented out, because part 5 should use all possible information
    # # if there is a sleeplog location then only use measurements with sleeplog
    # if (length(loglocation) > 0) { #do you want to fall back on generic assumptions about sleep if sleep log is not available?
    #   only.use.sleeplog = TRUE
    # } else {
    #   only.use.sleeplog = FALSE
    # }
    # # delete nights without diary, with limited or no acceleration:
    # if (only.use.sleeplog == TRUE) {
    #   del = which(as.numeric(as.character(outputfinal$cleaningcode)) > 0 |
    #                 as.character(outputfinal$sleeplog_used) == "FALSE" | 
    #                 as.character(outputfinal$acc_available) == "FALSE")
    # } else {
      #only delete nights with no or no valid accelerometer data, but consider nigths with missing sleep log data
      # del = which(as.numeric(as.character(outputfinal$cleaningcode)) > 1 | as.character(outputfinal$acc_available) == "FALSE") 
    # }
    # if (length(del) > 0) {
    #   outputfinal = outputfinal[-del,]
    # }
    #-----------------------------------------------------------
    # split results to different spreadsheets in order to minimize individual filesize and to ease organising dataset
    uwi = as.character(unique(outputfinal$window))
    uTRLi = as.character(unique(outputfinal$TRLi))
    uTRMi = as.character(unique(outputfinal$TRMi))
    uTRVi = as.character(unique(outputfinal$TRVi))
    usleepparam = as.character(unique(outputfinal$sleepparam))
    # replace NaN by empty cell value
    for (kra in 1:ncol(outputfinal)) {
      krad = which(as.character(outputfinal[,kra]) == "NaN")
      if (length(krad) > 0) {
        outputfinal[krad,kra] = ""
      }
    }
    # loop to store varous variants of the analysis seperately
    cat(" generating output for every parameter configurations...\n")
    for (j in 1:length(uwi)) {
      for (h1 in 1:length(uTRLi)) {
        for (h2 in 1:length(uTRMi)) {
          for (h3 in 1:length(uTRVi)) {
            for (h4 in 1:length(usleepparam)) {
              cat(paste0(" ",uwi[j],"-",uTRLi[h1],"-",uTRMi[h2],"-",uTRVi[h3],"-",usleepparam[h4]))
              seluwi = which(as.character(outputfinal$window) == uwi[j] & 
                               as.character(outputfinal$TRLi) == uTRLi[h1] &
                               as.character(outputfinal$TRMi) == uTRMi[h2] &
                               as.character(outputfinal$TRVi) == uTRVi[h3] &
                               as.character(outputfinal$sleepparam) == usleepparam[h4])
              # store spreadsheet
              if (nrow(outputfinal[seluwi,]) == 0) {
                cat("report not stored, because no results available")
              } else {
                
                # first update variable names
                LT = as.character(max(uTRLi))#as.character(outputfinal[seluwi[1],which(colnames(outputfinal) == "TRLi")])
                MT = as.character(max(uTRMi)) # as.character(outputfinal[seluwi[1],which(colnames(outputfinal) == "TRMi")])
                VT = as.character(max(uTRVi))#as.character(outputfinal[seluwi[1],which(colnames(outputfinal) == "TRVi")])
                CN = colnames(outputfinal)
                for (z4 in 1:length(CN)) {
                  # IN and OIN
                  tr1 = unlist(strsplit(CN[z4],paste("IN",LT,sep="")))
                  if (length(tr1) > 1) CN[z4] =  paste(tr1[1],"IN",uTRLi[h1],tr1[2],sep="")
                  # LIG
                  tr2 = unlist(strsplit(CN[z4],paste("LIG",LT,"_",MT,sep="")))
                  if (length(tr2) > 1) CN[z4] =  paste(tr2[1],"LIG",uTRLi[h1],"_",uTRMi[h2],tr2[2],sep="")
                  # MOD
                  tr3 = unlist(strsplit(CN[z4],paste("MOD",MT,"_",VT,sep="")))
                  if (length(tr3) > 1) CN[z4] =  paste(tr3[1],"MOD",uTRMi[h2],"_",uTRVi[h3],tr3[2],sep="")                  
                  # VIG
                  tr4 = unlist(strsplit(CN[z4],paste("VIG",VT,sep="")))
                  if (length(tr4) > 1) CN[z4] =  paste(tr4[1],"VIG",uTRVi[h3],tr4[2],sep="")
                  # MVPA with T_ mod _ m #for mg and min
                  tr5 = unlist(strsplit(CN[z4],paste("T",MT,"_m",sep="")))
                  if (length(unlist(strsplit(CN[z4],"MVPA"))) > 1 &
                      length(tr5) > 1) CN[z4] =  paste(tr5[1],"T",uTRMi[h2],"_m",tr5[2],sep="")                  
                  # INB with T_ mod _ m
                  tr6 = unlist(strsplit(CN[z4],paste("T",LT,"_m",sep="")))
                  if (length(unlist(strsplit(CN[z4],"INB"))) > 1 &
                      length(tr6) > 1) CN[z4] =  paste(tr6[1],"T",uTRLi[h1],"_m",tr6[2],sep="")                  
                  # LIGB with T_ mod _ m
                  tr7 = unlist(strsplit(CN[z4],paste("T",LT,"_",MT,"_m",sep="")))
                  if (length(unlist(strsplit(CN[z4],"LIGB"))) > 1 &
                      length(tr7) > 1) CN[z4] =  paste(tr7[1],"T",uTRLi[h1],"_",uTRMi[h2],"_m",tr7[2],sep="")
                  #Nbouts
                  tr15 = unlist(strsplit(CN[z4],paste("outs_INB",sep="")))
                  tr16 = unlist(strsplit(CN[z4],paste("outs_MVP",sep="")))
                  tr17 = unlist(strsplit(CN[z4],paste("outs_LIGB",sep="")))
                  if (length(tr15) > 1) {
                    CN[z4] = paste0(unlist(strsplit(CN[z4],paste("T",sep="")))[1],"T",uTRLi[h1])
                  }
                  if (length(tr16) > 1) {
                    CN[z4] = paste0(unlist(strsplit(CN[z4],paste("T",sep="")))[1],"T",uTRMi[h2])
                  }
                  if (length(tr17) > 1) {
                    CN[z4] = paste0(unlist(strsplit(CN[z4],paste("T",sep="")))[1],"T",uTRLi[h1],"_",uTRMi[h2])
                  }
                  #Nblocks
                  tr8 = unlist(strsplit(CN[z4],"ocks")) #Nblocks
                  if (length(tr8) > 1) {
                    CNtemp = paste0(CN[z4],"dummy")
                    # IN and OIN
                    tr9 = unlist(strsplit(CNtemp,paste("IN",LT,sep="")))
                    if (length(tr9) > 1) {
                      CNtemp =  paste(tr9[1],"IN",uTRLi[h1],sep="")
                    }
                    # LIG
                    tr10 = unlist(strsplit(CNtemp,paste("LIG",LT,"_",MT,sep="")))
                    if (length(tr10) > 1) CNtemp =  paste(tr10[1],"LIG",uTRLi[h1],"_",uTRMi[h2],sep="")
                    # MOD
                    tr11 = unlist(strsplit(CNtemp,paste("MOD",MT,"_",VT,sep="")))
                    if (length(tr11) > 1) CNtemp =  paste(tr11[1],"MOD",uTRMi[h2],"_",uTRVi[h3],sep="")                  
                    # VIG
                    tr12 = unlist(strsplit(CNtemp,paste("VIG",VT,sep="")))
                    if (length(tr12) > 1) CNtemp =  paste(tr12[1],"VIG",uTRVi[h3],sep="")
                    # MVPA with T_ mod _ m #for mg and min
                    tr13 = unlist(strsplit(CNtemp,paste("T",MT,sep="")))
                    if (length(unlist(strsplit(CNtemp,"MVPA"))) > 1 &
                        length(tr13) > 1) CNtemp =  paste(tr13[1],"T",uTRMi[h2],sep="")                  
                    # INB with T_ mod _ m
                    tr14 = unlist(strsplit(CNtemp,paste("T",LT,sep="")))
                    if (length(unlist(strsplit(CNtemp,"INB"))) > 1 &
                        length(tr14) > 1) CNtemp =  paste(tr14[1],"T",uTRLi[h1],sep="")                  
                    # LIGB with T_ mod _ m
                    tr14 = unlist(strsplit(CNtemp,paste("T",LT,"_",MT,sep="")))
                    if (length(unlist(strsplit(CNtemp,"LIGB"))) > 1 &
                        length(tr14) > 1) CNtemp =  paste(tr14[1],"T",uTRLi[h1],"_",uTRMi[h2],sep="")                 
                    if (length(unlist(strsplit(CNtemp,"dum"))) > 1) {
                      CN[z4] = unlist(strsplit(CNtemp,"dum"))[1]
                    } else {
                      CN[z4] = CNtemp
                    }
                  }
                  #                   # Nblocks and MVPA with T_ mod 
                  #                   tr5 = unlist(strsplit(CN[z4],paste("T",MT,sep="")))
                  #                   if (length(unlist(strsplit(CN[z4],"MVPA"))) > 1 &
                  #                         length(unlist(strsplit(CN[z4],"Nblocks"))) > 1) CN[z4] =  paste(tr5[1],"T",uTRMi[h2],sep="")                  
                  #                   # Nblocks and INB with T_ mod _ m
                  #                   tr6 = unlist(strsplit(CN[z4],paste("T",LT,sep="")))
                  #                   if (length(unlist(strsplit(CN[z4],"INB"))) > 1 &
                  #                         length(unlist(strsplit(CN[z4],"Nbolcks"))) > 1) CN[z4] =  paste(tr6[1],"T",uTRLi[h1],sep="")                  
                  #                   CN[z4] = paste(CN[z4],"qdd",sep="") # add dummy character
                  #                   CNtemp = as.character(unlist(strsplit(CN[z4],"qdd"))) # remove dummy character
                  CNtemp = CN[z4]
                  if (length(which(CNtemp =="")) >= 1) CNtemp = CNtemp[-which(CNtemp =="")] 
                  CN[z4] = CNtemp
                }
                outputfinal2 = outputfinal
                colnames(outputfinal2) = CN
                delcol = which(colnames(outputfinal2) == "window" | colnames(outputfinal2) == "TRLi" |
                                 colnames(outputfinal2) == "TRMi" | colnames(outputfinal2) == "TRVi" |
                                 colnames(outputfinal2) == "sleepparam")
                outputfinal2 = outputfinal2[,-delcol]
                OF3 = outputfinal2[seluwi,]
                
                OF3$daytype = 0
                OF3$daytype[which(OF3$weekday == "Sunday" | OF3$weekday == "Saturday")] = "WE"
                OF3$daytype[which(OF3$weekday == "Monday" | OF3$weekday == "Tuesday" |
                                    OF3$weekday == "Wednesday" | OF3$weekday == "Thursday" |
                                    OF3$weekday == "Friday")] = "WD"
                OF3 = as.data.frame(OF3)
                OF3$nonwear_perc_wakinghours = as.numeric(OF3$nonwear_perc_wakinghours)
                OF3$nonwear_perc_sleepperiod = as.numeric(OF3$nonwear_perc_sleepperiod)
                OF3$dur_sleepperiod_min = as.numeric(OF3$dur_sleepperiod_min)
                OF3$dur_wakinghours_min = as.numeric(OF3$dur_wakinghours_min)
                OF3$guider = as.character(OF3$guider)
                OF3$sleeplog_used = as.numeric(OF3$sleeplog_used)
                #-------------------------------------------------------------
                # store all summaries in csv files without cleaning criteria
                
                write.csv(OF3,paste(metadatadir,"/results/QC/part5_daysummary_full_",
                                    uwi[j],"_L",uTRLi[h1],"M",uTRMi[h2],"V",uTRVi[h3],"_",usleepparam[h4],".csv",sep=""),row.names=FALSE)
                # store all summaries in csv files with cleaning criteria
                validdaysi = getValidDayIndices(OF3,includenightcrit, includedaycrit) 
                write.csv(OF3[validdaysi,],paste(metadatadir,"/results/part5_daysummary_",
                                                      uwi[j],"_L",uTRLi[h1],"M",uTRMi[h2],"V",uTRVi[h3],"_",usleepparam[h4],".csv",sep=""),row.names=FALSE)
                #------------------------------------------------------------------------------------
                #also compute summary per person
                agg_plainNweighted = function(df,filename="filename",daytype="daytype") {
                  # function to take both the weighted (by weekday/weekendday) and plain average of all numeric variables
                  # df: input data.frame (OF3 outside this function)
                  ignorevar = c("daysleeper","cleaningcode","night_number","sleeplog_used","id","acc_available","window_number")
                  for (ee in 1:ncol(df)) { # make sure that numeric columns have class numeric
                    nr = nrow(df)
                    if (nr > 30) nr = 30
                    options(warn=-1)
                    trynum = as.numeric(as.character(df[1:nr,ee]))
                    options(warn=0)
                    if (length(which(is.na(trynum) == TRUE)) != nr & length(which(ignorevar == names(df)[ee])) == 0) {
                      options(warn=-1)
                      class(df[,ee]) = "numeric"
                      options(warn=0)
                    }
                  }
                  plain_mean = function(x) {
                    options(warn=-1)
                    plain_mean = mean(x,na.rm=TRUE)
                    options(warn=0)
                    if (is.na(plain_mean) == TRUE) {
                      plain_mean = x[1]
                    }
                    return(plain_mean)
                  }
                  # aggregate across all days
                  PlainAggregate = aggregate.data.frame(df,by=list(df$filename),FUN=plain_mean)
                  PlainAggregate = PlainAggregate[,-1]
                  # aggregate per day type (weekday or weekenddays)
                  AggregateWDWE = aggregate.data.frame(df,by=list(df$filename,df$daytype),plain_mean)
                  AggregateWDWE = AggregateWDWE[,-c(1:2)]
                  len = NULL
                  AggregateWDWE$len <- 0
                  AggregateWDWE$len[which(as.character(AggregateWDWE$daytype) == "WD")] = 5
                  AggregateWDWE$len[which(as.character(AggregateWDWE$daytype) == "WE")] = 2
                  dt <- data.table::as.data.table(AggregateWDWE[,which(lapply(AggregateWDWE, class)=="numeric" | names(AggregateWDWE) == filename)])
                  options(warn=-1)
                  .SD <- .N <- count <- a <- NULL
                  WeightedAggregate <- dt[,lapply(.SD,weighted.mean,w=len,na.rm=TRUE),by=list(filename)]
                  options(warn=0)
                  # merge them into one output data.frame (G)
                  charcol = which(lapply(PlainAggregate, class) != "numeric" & names(PlainAggregate) != filename)
                  numcol = which(lapply(PlainAggregate, class) == "numeric")
                  WeightedAggregate = as.data.frame(WeightedAggregate)
                  G = base::merge(PlainAggregate,WeightedAggregate,by="filename",all.x=TRUE)
                  p0b = paste0(names(PlainAggregate[,charcol]),".x")
                  p1 = paste0(names(PlainAggregate[,numcol]),".x")
                  p2 = paste0(names(PlainAggregate[,numcol]),".y")
                  for (i in 1:length(p0b)) {
                    names(G)[which(names(G)==p0b[i])] = paste0(names(PlainAggregate[,charcol])[i])
                  }
                  for (i in 1:length(p1)) {
                    names(G)[which(names(G)==p1[i])] = paste0(names(PlainAggregate[,numcol])[i],"_pla")
                  }
                  for (i in 1:length(p2)) {
                    names(G)[which(names(G)==p2[i])] = paste0(names(PlainAggregate[,numcol])[i],"_wei")
                  }
                  G = G[,-which(names(G)=="len" | names(G)=="daytype")]
                  return(G)
                }
                #---------------------------------------------
                # Calculate, weighted and plain mean of all variables
                # add column to define what are weekenddays and weekdays as needed for function agg_plainNweighted
                # before processing OF3, first identify which days have enough monitor wear time
               validdaysi = getValidDayIndices(OF3,includenightcrit, includedaycrit) 
                if (length(validdaysi) >0) { # do not attempt to aggregate if there are no valid days
                  # aggregate OF3 (days) to person summaries in OF4
                  OF4 = agg_plainNweighted(OF3[validdaysi,],filename="filename",day="daytype")
                  # calculate additional variables
                  OF3tmp = OF3[,c("filename","night_number","daysleeper","cleaningcode","sleeplog_used","guider",
                                  "acc_available","nonwear_perc_wakinghours","nonwear_perc_sleepperiod","daytype","dur_wakinghours_min",
                                  "dur_sleepperiod_min")]
                  
                  foo34 = function(df,aggPerIndividual,nameold,namenew,cval) {
                    # function to help with calculating additinal variables
                    # related to counting how many days of measurement there are
                    # that meet a certain criteria
                    # cval is a vector with 0 and 1, indicating whether the criteria is met
                    # aggPerIndividual is the aggregate data (per individual)
                    # df is the non-aggregated data (days across individuals
                    # we want to extra the number of days per individuals that meet the
                    # criteria in df, and make it allign with aggPerIndividual.
                    df2 = function(x) df2 = length(which(x==cval)) # check which values meets criterion
                    mmm = as.data.frame(aggregate.data.frame(df,by=list(df$filename),FUN = df2))
                    mmm2 = data.frame(filename=mmm$Group.1,cc=mmm[,nameold])
                    aggPerIndividual = merge(aggPerIndividual,mmm2,by="filename")
                    names(aggPerIndividual)[which(names(aggPerIndividual)=="cc")] = namenew
                    foo34 = aggPerIndividual
                    
                    
                  }
                  # # calculate number of valid days (both night and day criteria met)
                  OF3tmp$validdays = 0
                  # criteria is that nonwear percentage needs to be below threshold for both day and night:
                  OF3tmp$validdays[validdaysi] = 1
                  # now we have a label for the valid days, we can create a new variable 
                  # in OF4 that is a count of the number of valid days:
                  OF4 = foo34(df=OF3tmp,aggPerIndividual=OF4,nameold="validdays",namenew="Nvaliddays",cval=1)
                  # do the same for WE (weekend days):
                  OF3tmp$validdays = 0
                  OF3tmp$validdays[validdaysi[which(OF3tmp$daytype[validdaysi] == "WE")]] = 1
                  OF4 = foo34(df=OF3tmp,aggPerIndividual=OF4,nameold="validdays",namenew="Nvaliddays_WE",cval=1)
                  # do the same for WD (weekdays):
                  OF3tmp$validdays = 0
                  OF3tmp$validdays[validdaysi[which(OF3tmp$daytype[validdaysi] == "WD")]] = 1
                  OF4 = foo34(df=OF3tmp,aggPerIndividual=OF4,nameold="validdays",namenew="Nvaliddays_WD",cval=1) # create variable from it
                  # do the same for daysleeper,cleaningcode, sleeplog_used, acc_available:
                  OF3tmp$validdays = 1
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="daysleeper",namenew="Ndaysleeper",cval=1)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="cleaningcode",namenew="Ncleaningcodezero",cval=0)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="cleaningcode",namenew="Ncleaningcode1",cval=1)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="cleaningcode",namenew="Ncleaningcode2",cval=2)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="cleaningcode",namenew="Ncleaningcode3",cval=3)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="cleaningcode",namenew="Ncleaningcode4",cval=4)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="cleaningcode",namenew="Ncleaningcode5",cval=5)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="sleeplog_used",namenew="Nsleeplog_used",cval=TRUE)
                  OF4 = foo34(df=OF3tmp[validdaysi,],aggPerIndividual=OF4,nameold="acc_available",namenew="Nacc_available",cval=1)
                  # Move valid day count variables to beginning of dataframe
                  OF4 = cbind(OF4[,1:5],OF4[,(ncol(OF4)-10):ncol(OF4)],OF4[,6:(ncol(OF4)-11)])
                  nom = names(OF4)
                  cut = which(nom == "sleeponset_ts" | nom == "wakeup_ts" | nom == "night_number"  | nom == "window_number" 
                              | nom == "daysleeper" | nom == "cleaningcode" | nom == "acc_available"
                              | nom == "guider" | nom == "L5TIME" | nom == "M5TIME"
                              | nom == "L10TIME" | nom == "M10TIME" | nom == "acc_available")
                  names(OF4)[which(names(OF4)=="weekday")] = "startday"
                  OF4 = OF4[,-cut]
                  OF4 = as.matrix(OF4)
                  OF4[which(is.na(OF4) == TRUE)] = ""
                  #-------------------------------------------------------------
                  # store all summaries in csv files
                  write.csv(OF4,paste(metadatadir,"/results/part5_personsummary_",
                                      uwi[j],"_L",uTRLi[h1],"M",uTRMi[h2],"V",uTRVi[h3],"_",usleepparam[h4],".csv",sep=""),row.names=FALSE)
                }
              }
            }
            
          }
        }
      }
    }
    rm(outputfinal, outputfinal2)
  }
}
